using Kmd.Logic.FileSecurity.Client.Models;
using Kmd.Logic.FileSecurity.Client.ServiceMessages;
using Kmd.Logic.FileSecurity.Client.Types;
using Kmd.Logic.Identity.Authorization;
using Microsoft.Rest;
using System;
using System.Net.Http;
using System.Threading.Tasks;

namespace Kmd.Logic.FileSecurity.Client
{
    /// <summary>
    /// Class to use the autogenerated client class to call APIs
    /// </summary>
    public sealed class FileSecurityClient : IDisposable
    {
        private readonly HttpClient _httpClient;
        private readonly FileSecurityOptions _options;
        private readonly ITokenProviderFactory _tokenProviderFactory;
        private InternalClient _internalClient;

        /// <summary>
        /// Initializes a new instance of the <see cref="FileSecurityClient"/> class.
        /// </summary>
        /// <param name="httpClient">The HTTP client to use. The caller is expected to manage this resource and it will not be disposed.</param>
        /// <param name="tokenProviderFactory">The Logic access token provider factory.</param>
        /// <param name="options">The required configuration options.</param>
        public FileSecurityClient(HttpClient httpClient, ITokenProviderFactory tokenProviderFactory, FileSecurityOptions options)
        {
            this._httpClient = httpClient ?? throw new ArgumentNullException(nameof(httpClient));
            this._options = options ?? throw new ArgumentNullException(nameof(options));
            this._tokenProviderFactory = tokenProviderFactory ?? throw new ArgumentNullException(nameof(tokenProviderFactory));
        }

        /// <summary>
        /// Creates certificate
        /// </summary>
        /// <param name="createCertificateRequestDetails"></param>
        /// <returns></returns>
        public async Task<CreateCertificateResponse> CreateCertificate(CreateCertificateRequestDetails createCertificateRequestDetails)
        {
            var client = this.CreateClient();

            using (var certificateDetailsResponse = await client.SaveCertificatesWithHttpMessagesAsync(
                 this._options.SubscriptionId,
                 createCertificateRequestDetails.Name,
                 createCertificateRequestDetails.Certificate,
                 createCertificateRequestDetails.CertificatePassword).ConfigureAwait(false))
            {
                switch (certificateDetailsResponse?.Response?.StatusCode)
                {
                    case System.Net.HttpStatusCode.OK:
                        return certificateDetailsResponse.Body;

                    case System.Net.HttpStatusCode.NotFound:
                        return null;

                    default:
                        throw new FileSecurityException(certificateDetailsResponse?.Body?.ToString() ?? "Invalid configuration provided to access File Security service");
                }
            }
        }

        internal InternalClient CreateClient()
        {
            if (this._internalClient != null)
            {
                return this._internalClient;
            }

            var tokenProvider = this._tokenProviderFactory.GetProvider(this._httpClient);

            this._internalClient = new InternalClient(new TokenCredentials(tokenProvider))
            {
                BaseUri = this._options.FileSecurityServiceUri,
            };

            return this._internalClient;
        }

        public void Dispose()
        {
            this._httpClient?.Dispose();
            this._tokenProviderFactory?.Dispose();
            this._internalClient?.Dispose();
        }
    }
}
